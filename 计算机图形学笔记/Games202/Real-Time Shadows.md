# Real-Time Shadows

## Shadow Mapping

### Shadow Mapping的算法

+ 使用两趟Pass
	+ 第一趟Pass从光源所在的地方看向场景，并输出一个阴影贴图，来记录场景中最近的深度。<img src="https://img2024.cnblogs.com/blog/3406761/202408/3406761-20240804210437322-936155349.png" style="zoom: 33%;" />
	+ 第二趟Pass使用第一趟渲染出的阴影贴图通过比较当前像素的深度与记录的深度来判断看到的物体是否在阴影内。



### Shadow Mapping的问题

#### Self Occlusion（自遮挡）

由于阴影贴图记录的是**离散的像素**，而一片像素记录的深度又是相同的，因此当摄像机看到一个点时，该点的**实际深度**与**阴影贴图中记录的深度**就会有很小的偏差。如下图中的点p，其实际深度为$d(p_1)$,但从阴影贴图中采样的深度为s，两者s小于$d(p_1)$，因此会被判定为阴影，但实际上p点并没有被遮挡，这就会形成自遮挡。自遮挡的剧烈程度和光照与平面的角度有关，也就是**光照方向**与该点的**法线方向**形成的夹角越小，对应的余弦值越小，自遮挡越严重。

<img src="https://img2024.cnblogs.com/blog/3406761/202408/3406761-20240804211556730-1509518714.png" style="zoom:50%;" />

#### 自遮挡的解决方法

**引入偏移**

在第二趟Pass判断深度时加上一个bias（偏移），来增加容忍度，同时由于自遮挡的剧烈程度与角度有关，因此可以通过夹角的余弦值来实时控制偏移的值，在角度大时偏移小，角度小时便宜大。 但该方法会造成detached shadow（不接触的阴影），也就是当偏移取得过大时，会使一些本该出现阴影的地方没有阴影。

**Second-depth Shadow Mapping**

进行第一趟Pass时不仅存储最小深度，还存储第二小的深度，在比较时使用两个深度的中间深度与实际深度进行比较。这样虽然不会发生自遮挡现象，但该方法要求物体必须为watertight，也就是必须有两面，地板这种没有反面的物体次浅深度可以为无限大，同时加入一个次小深度会时间消耗变大。<img src="https://img2024.cnblogs.com/blog/3406761/202408/3406761-20240804214635090-1583912226.png" style="zoom: 80%;" />



## Shadow Mapping背后的知识

**积分的约等式：**

<img src="https://img2024.cnblogs.com/blog/3406761/202408/3406761-20240827181340004-647587733.png" style="zoom:50%;" />

近似的使用条件：

1. 当积分域很小时，近似比较准确。
2. 当$g(x)$在积分域中变化不大，近似比较准确。

**约等式的使用：**

可以使用该约等式将可见性从积分中拆出来，从而先进行Shading，在进行乘上可见性。![](https://img2024.cnblogs.com/blog/3406761/202408/3406761-20240827181257031-316217321.png)

![](https://img2024.cnblogs.com/blog/3406761/202408/3406761-20240827181417757-370564503.png)

当光源为点光源或是方向光时近似较准确。

当光源的radiance不变，BRDF为diffuse时较准确。



## Percentage Closer Filtering(PCF)

+ PCF不是对已经有锯齿的阴影进行过滤。

+ 不是对Shadow Map进行过滤。

PCF的解决办法：

1. 将ShadingPoint连向光源后，不只选取对应的一个像素，而是选取ShadowMap上对应像素**特定范围内的所有像素**。
2. 对所选的所有像素进行比较，得到0或1表示visibility。
3. 对所有的visibility进行平均。



## Percentage Closer Soft Shadow(PCSS)

PCSS的核心是PCF，本质上是通过特定的手段选取适应性的FilterSize，再根据得到的FilterSize对阴影进行过滤。

<img src="https://img2024.cnblogs.com/blog/3406761/202409/3406761-20240906175406684-965106186.png" style="zoom: 50%;" />

当光源的面积越大时，或当遮挡物距离阴影越远时，阴影越平滑，由此可以使用下列式子表示选取FilterSize的大小：

![](https://img2024.cnblogs.com/blog/3406761/202409/3406761-20240906175442599-928133413.png)

blocker depth：
所有有可能挡住ShadingPoint的物体到光源的平均距离。

### PCSS的算法

1. （Blocker Search）获取特定范围内所有遮挡物并计算所有blocker depth的平均值。
2. 使用平均blocker depth去计算FilterSize。
3. 使用PCF计算阴影。

<img src="https://img2024.cnblogs.com/blog/3406761/202409/3406761-20240906181812646-46161937.png" style="zoom:50%;" />

在进行PCSS前，我们还需要先选取特定的范围来获取平均blocker depth。可将ShadingPoint连向Light，形成一个视锥体，而ShadowMap和Light分别在近平面和远平面，看ShadowMap对应了多大的区域。

### PCSS的缺点及优化

缺点：第一步和第二步使用了过大的FilterSize，需要进行大量的采样操作。

优化：可进行稀疏采样，使用泊松圆盘、均匀圆盘等圆盘滤波核对滤波区域进行随机采样，减少采样次数。但由此最后计算出的visibility也会带有噪声，可进行图像空间的降噪来提高画质。



## Variance Soft Shadow Mapping

### 优化PCF

在PCSS的第三步PCF中，我们选取了一个区域对采样结果进行滤波，而滤波中要做的一步便是比较当前像素与滤波核中像素的深度，从而找到比自身浅的像素的百分比，因此我们本质上希望得到的是当前像素在滤波核中**深度大于ShadingPoint**的像素的**百分比**。若对精准度要求不是过高，可将像素的深度分布当成正态分布，那么只需要知道均值与方差，就可以得到一定范围内当前像素所处的百分比。

**Mean(平均值):**

1. MipMap: 想要获得特定范围的的平均值可使用MipMap，但其精准度不是很高，因为在不同的层级之间需要进行插值，且只能处理正方形的情况。
2. Summed Area Tables(SAT).

**Variance(方差):**

<img src="https://img2024.cnblogs.com/blog/3406761/202409/3406761-20240926210018769-973693971.png" style="zoom:50%;" />

其中$E^2(x)$可从ShdowMap中获取，而$E(x^2)$只需要在生成ShdowMap时顺便计算$x^2$,并存在另一张纹理中，或存在ShdowMap中的其他通道。

**切比雪夫不等式：**

<img src="https://img2024.cnblogs.com/blog/3406761/202409/3406761-20240926210935632-1767090061.png" style="zoom:50%;" />

使用切比雪夫不等式可得到变量x大于某个常数t的概率的上界，当常数**t大于均值**时，该公式可用来**近似**x大于t的概率。

### 优化BlockSearch

在PCSS的第一步中，需要求一定范围内遮挡物的平均深度，也就是深度值小于当前深度的像素的平均深度。而对于遮挡物深度$Zocc$、非遮挡物深度$Zunocc$和整个氛围的平均深度$Zavg$，可以得到这么一个关系：
<img src="https://img2024.cnblogs.com/blog/3406761/202409/3406761-20240926213055900-1253228509.png" style="zoom:50%;" />

而其中的$N_1/N$，为大于当前深度的像素的比例，可使用前面提到的切比雪夫不等式来近似；$N_2/N$自然是$1-N_1/N$，$Zavg$可通过MipMap或SAT得到。那么就只剩下两个变量$Zocc$和$Zunocc$了，其中$Zocc$是我们希望求得的。至于$Zunocc$，VSM使用了一个大胆的假设，即所有非遮挡物的深度都为当前像素的深度，那么$Zunocc$即为当前像素的深度。当然这种假设只是近似而不正确的，当接受物为曲面或与光源不平行时就会出现问题。



### Average(均值)

前面已经提到可使用切比雪夫不等式来近似深度大于ShadingPoint的像素的比例，而求解不等式有需要得到均值，均值可使用**MipMap**来近似或是**SAT**来计算。

#### MipMap

MipMap本身是用来做**快速的、近似的、方形**的范围查询，在计算像素时MipMap使用了相邻像素的插值，在需要非$2^n$的层级时，还需要在层与层之间进行插值，由此会带来一定的误差。对于非正方形的情况同样也并不准确，这一点可使用各向异性过滤。<img src="https://img2024.cnblogs.com/blog/3406761/202409/3406761-20240926220015942-276030613.png" style="zoom: 67%;" />

#### Summed Area Tables(SAT)

SAT是一个完全准确的方法，其涉及到了前缀和的算法。

**在一维的情况下：**

对于一个一维数组：

<img src="https://img2024.cnblogs.com/blog/3406761/202409/3406761-20240926220616964-1160643627.png" style="zoom: 33%;" />

先对该数组进行预计算，创建一个新的数组，每一个元素来储存原数组前方所有蒜素的总和。对于查询**中间部分元素的和**，如计算3，7，1的和，可使用**最后一个**元素对应的前缀和减去**首元素前一个**元素的前缀和，即20减9。

<img src="https://img2024.cnblogs.com/blog/3406761/202409/3406761-20240926220720582-1727905195.png" style="zoom:33%;" />

**在二维的情况下：**

![](https://img2024.cnblogs.com/blog/3406761/202409/3406761-20240926222512170-1564677167.png)

对于二维情况，可先对一张二维纹理进行与计算，从左上角开始，每一个像素记录的是从**左上角到当前像素**所形成的矩形的**所有元素的和**。计算时为了提高效率可先对所有行进行并行计算，从左边加到右边，再并行计算所有列，从上面加到下面。当我们需要得到图一中间蓝色部分的和时，可通过图二绿色部分的和减去图三、四的和在加上图五的和，对应的和即储存在**最右下角**的元素上。

### VSSM的缺点

1. **分布估计带来的问题：**

	当阴影的分布不是一个单峰值的分布而是多峰值时，会出现漏光的情况。例如当使用切比雪夫不等式进行估计时，会产生红色面积的非遮挡物估计，而实际的分布式是蓝色的多峰值分布，那么实际只有蓝色部分的非遮挡物，就会造成过多的估计非遮挡物的比例，进而出现本应该在阴影中的像素不再阴影中。![](https://img2024.cnblogs.com/blog/3406761/202409/3406761-20240926224238606-1353618387.png)

2. 当**接受物不是平面**时出现问题。

3. **切比雪夫不等式的估计**带来的问题。



## Moment Shadow Mapping

MSM解决了VSM中描述分布不准的问题，它使用了使用了四阶或者更高阶的距，而VSSM实际上使用了前两阶矩。m阶矩可以描述$m/2$个阶梯的函数，使用四阶矩可以很好的描述真正的CDF。而如何使用前四阶矩来得到两个台阶的函数可阅读这篇Paper。[Moment Shadow Mapping (acm.org)](https://dl.acm.org/doi/pdf/10.1145/2699276.2699277)

![](https://img2024.cnblogs.com/blog/3406761/202409/3406761-20240926225322941-1162986756.png)