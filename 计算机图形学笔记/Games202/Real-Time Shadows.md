# Real-Time Shadows

## Shadow Mapping

### Shadow Mapping的算法

+ 使用两趟Pass
	+ 第一趟Pass从光源所在的地方看向场景，并输出一个阴影贴图，来记录场景中最近的深度。<img src="https://img2024.cnblogs.com/blog/3406761/202408/3406761-20240804210437322-936155349.png" style="zoom: 33%;" />
	+ 第二趟Pass使用第一趟渲染出的阴影贴图通过比较当前像素的深度与记录的深度来判断看到的物体是否在阴影内。

### Shadow Mapping的问题

#### Self Occlusion（自遮挡）

由于阴影贴图记录的是**离散的像素**，而一片像素记录的深度又是相同的，因此当摄像机看到一个点时，该点的**实际深度**与**阴影贴图中记录的深度**就会有很小的偏差。如下图中的点p，其实际深度为$d(p_1)$,但从阴影贴图中采样的深度为s，两者s小于$d(p_1)$，因此会被判定为阴影，但实际上p点并没有被遮挡，这就会形成自遮挡。自遮挡的剧烈程度和光照与平面的角度有关，也就是**光照方向**与该点的**法线方向**形成的夹角越小，对应的余弦值越小，自遮挡越严重。

<img src="https://img2024.cnblogs.com/blog/3406761/202408/3406761-20240804211556730-1509518714.png" style="zoom:50%;" />

#### 自遮挡的解决方法

**引入偏移**

在第二趟Pass判断深度时加上一个bias（偏移），来增加容忍度，同时由于自遮挡的剧烈程度与角度有关，因此可以通过夹角的余弦值来实时控制偏移的值，在角度大时偏移小，角度小时便宜大。 但该方法会造成detached shadow（不接触的阴影），也就是当偏移取得过大时，会使一些本该出现阴影的地方没有阴影。

**Second-depth Shadow Mapping**

进行第一趟Pass时不仅存储最小深度，还存储第二小的深度，在比较时使用两个深度的中间深度与实际深度进行比较。这样虽然不会发生自遮挡现象，但该方法要求物体必须为watertight，也就是必须有两面，地板这种没有反面的物体次浅深度可以为无限大，同时加入一个次小深度会时间消耗变大。<img src="https://img2024.cnblogs.com/blog/3406761/202408/3406761-20240804214635090-1583912226.png" style="zoom: 80%;" />