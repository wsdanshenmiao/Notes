# 派生与继承

## 继承的方式

>  派生类（子类）是从基类（父类）继承而来的类，派生类将继承基类的属性；
>
> ```c++
> class Entity
> {
> public:
> 	float X, Y;
> 	void Move(float ax, float ay)
> 	{
> 		X += ax;
> 		Y += ay;
> 	}
> };
> ```
>
> + **公有继承：基类中的公有成员继承为公有成员，保护成员继承为保护成员。**
>
> 	```c++
> 	class Player :public Entity	//派生类列表，公有继承
> 	{
> 	public:
> 		const char* name;
> 		void PrintName()
> 		{
> 			std::cout << name << std::endl;
> 		}
> 	};
> 	```
>
> + **保护继承：基类中的公有和保护成员都继承为保护成员。**
>
> 	```C++
> 	class Player :protected Entity
> 	```
>
> + **私有继承：基类中的公有和保护成员都继承为私有成员。**
>
> 	```c++
> 	class Player :private Entity
> 	```
>
> **==基类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到==**

## 继承中构造和析构顺序

> + **子类继承父类后，当创建子类对象，也会调用父类的构造函数。**
> + **继承中先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反。**

## 继承同名成员处理方式

> **继承同名非静态成员：**
>
> + 子类对象可以直接访问到子类中同名成员。
>
> 	```c++
> 	Player p;
> 	p.m_X;
> 	p.function();
> 	```
>
> + 子类对象加作用域可以访问到父类同名成员。
> 	```C++
> 	p.Entity::m_X;
> 	P.Entity::function();
> 	```
>
> + 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数。
>
> **继承同名静态成员：**
>
> + 通过对象访问时与非静态成员相同.
>
> + 通过类名访问时
>
> 	+ 访问子类中同名成员
> 		```c++
> 		Player::m_X；
> 		Player::function();
> 		```
>
> 	+ 访问父类中同名成员
> 		```c++
> 		Player::Entity：：m_X；
> 		Player::Entity::function()；
> 		```



# 可见性

> **可见性修饰符：public，projected，private**
>
> + **private：只有==该类及其友元==（friend修饰的类或函数）可以访问。**
> + **projected：==该类及其层次结构中的所有子类==都可访问。**
> + **public：可随意访问。**



# 虚函数

## 虚函数的基本概念

> 虚函数引入了动态联编，通过虚函数表（v表）实现编译。虚函数允许我们在**==子类中重写方法==**。
>
> 虚函数关键字：**==virtual==**，**==override==**。
>
> 虚函数表（v表）：
>
> + **虚函数表包含基类中所有虚函数的映射。**
> + **虚函数表可以在运行时将虚函数映射到正确的覆写函数。**
>
> ```c++
> class Entity
> {
> public:
> 	virtual std::string GetName() { return "Entity"; }	//虚函数
> };
> class Player :public Entity
> {
> private:
> 	std::string m_name;
> public:
> 	Player(const std::string& name) : m_name(name) {}
> 	std::string GetName() override { return m_name; }	//覆写函数
> };
> ```
>
> 虚函数的额外运行成本：
>
> + **需要**==额外的内存储==**存虚函数表，基类中需要一个**==成员指针==**指向虚函数表。**
> + **每次调用虚函数需要查找虚函数表，来确定映射到哪个函数，会造成额外的开销。**

## 纯虚函数

> 纯虚函数允许在基类定义一个没有实现的函数，然后强制派生类实现该函数。
>
> 创建一个类，只有未实现的方法组成，然后强制派生类去实现它们，这是C++中的接口。
>
> ```c++
> class Printable	//接口
> {
> public:
> 	virtual std::string GetClassName() = 0;	//构造纯虚函数
> };
> 
> class Entity : public Printable
> {
> public:
> 	virtual std::string GetName() { return "Entity"; }
> 	std::string GetClassName() override { return "Entity"; }
> };
> 
> class Player :public Entity
> {
> private:
> 	std::string m_name;
> public:
> 	Player(const std::string& name)
> 		:m_name(name) {}
> 	std::string GetName() override { return m_name; }
> 	std::string GetClassName() override { return "Player"; }
> };
> 
> void PrintName(Entity* entity)
> {
> 	std::cout << entity->GetClassName() << std::endl;
> }
> 
> int main()
> {
> 	Entity* e = new Entity();
> 	Player* p = new Player("wsdsm");
> 	PrintName(e);
> 	PrintName(p);
> 	delete e;
> 	delete p;
> }
> ```
>



# 友元

> 关键字：**==friend==**
>
> 友元的目的：让一个函数或者类 访问另一个类中私有成员。

## 全局函数做友元

> ```c++
> class Entity
> {
> public:
> 	int m_X;
> private:
> 	int m_Y;
> public:
> 	Entity()
> 	{
> 		this->m_X = 1;
> 		this->m_Y = 1;
> 	}
>     //告诉编译器 Function全局函数，是Entity类的友元，可以访问类中的私有内容
> 	friend void Function(Entity* e);
> };
> void Function(Entity* e)
> {
> 	e->m_X = 2;
> 	e->m_Y = 2;
> }
> ```

## 类做友元

> ```C++
> friend class Entity;
> ```

## 成员函数做友元

> ```C++
> friend void Entity::Function();
> ```