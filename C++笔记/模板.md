# 模板

> * C++另一种编程思想称为==泛型编程==，主要利用的技术就是模板
>
>
> * C++提供两种模板机制:**函数模板**和**类模板** 
>

## 函数模板

### 函数模板的基本概念

> 函数模板作用：
>
> 建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。
>
> **语法：** 
>
> ```C++
> template<typename T>	//函数声明或定义
> ```
>
> 示例：
>
> ```C++
> template<typename T>	////利用模板提供通用的交换函数
> void mySwap(T& a, T& b)
> {
> 	T temp = a;
> 	a = b;
> 	b = temp;
> }
> ```
>
> 模板实现函数有两种：
>
> 1. **自动类型推导**
>
> 	```c++
> 	mySwap(a, b);
> 	```
>
> 2. **显示指定类型**
>
> 	```c++
> 	mySwap<int>(a, b);	//指定T为int
> 	```
>
> **注意事项：**
>
> + 自动类型推导，必须推导出一致的数据类型T,才可以使用
>
>
> * 模板必须要确定出T的数据类型，才可以使用
>

### 普通函数和函数模板

#### 普通函数与函数模板区别：

> * **普通函数调用时可以发生==自动类型转换（隐式类型转换）==**
>
> * **函数模板调用时，如果==利用自动类型推导，不会发生隐式类型转换==**
>
> 	```C++
> 	template<class T>
> 	T myAdd02(T a, T b)  
> 	{
> 		return a + b;
> 	}
> 	void main()
> 	{
> 		int a = 10;
> 		int b = 20;
> 		char c = 'c';
> 		myAdd01(a, c);	//如果用自动类型推导，不会发生自动类型转换,即隐式类型转换
> 		//myAdd02(a, c);	//error，使用自动类型推导时，不会发生隐式类型转换
> 	}
> 	```
>
> * **如果==利用显示指定类型的方式，可以发生隐式类型转换==**
>
> 	```c++
> 	myAdd02<int>(a, c); //如果用显示指定类型，可以发生隐式类型转换
> 	```

#### 普通函数和函数模板的调用规则

> + 如果函数模板和普通函数都可以实现，**优先调用普通函数**
>
> + 可以**通过空模板参数列表来强制调用函数模板**
>
> * 函数模板也可以发生重载
>
> + 如果**函数模板可以产生更好的匹配,优先调用函数模板**
> + 既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性

#### 局限性

> 模板的通用性并不是万能的。
>
> 例如：
>
> ```C++
> template<class T>
> void function(T a, T b)
> { 
> 	if(a = b) { ... }
> }
> ```
>
> 若传入自定义数据类型，将无法运行，为了解决这种问题，可使用**模板的重载**，可以**为这些特定的类型提供具体化的模板。**
>
> ````C++
> class Entity
> {
> public:
> 	int m_X,m_Y;
> 	Entity(int x,int y)
> 		:m_X(x),m_Y(y){}
> };
> //普通函数模板
> template<class T>
> bool myCompare(T& a, T& b)
> {
> 	if (a == b){
> 		return true;
> 	}
> 	else{
> 		return false;
> 	}
> }
> //具体化（全特化）
> template<> bool myCompare(Entity& e1, Entity& e2)
> {
> 	if (e1.m_X == e2.m_X && e1.m_Y == e2.m_Y){
> 		return true;
> 	}
> 	else{
> 		return false;
> 	}
> }
> void main()
> {
> 	Entity e1(20, 10);
> 	Entity e2(20, 10);
> 	//自定义数据类型，不会调用普通的函数模板
> 	//可以创建具体化的Entity数据类型的模板，用于特殊处理这个类型
> 	bool ret = myCompare(e1, e2);
> }
> ````
>
> 注意事项：
>
> + 类模板和函数模板都可以被全特化
>
> + 函数模板可以实现重载，不能被偏特化